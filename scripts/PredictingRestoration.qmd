---
title: "Predicting Restoration Time"
authors: Jiwon Bae (jb5234) and Hillary Rodriguez (hnr2112)
execute:
  echo: true
  warning: false
  message: false
format:
  html:
    fig-width: 6
    fig-height: 4
    out-width: 60%
    embed-resources: true
---

```{r}
suppressPackageStartupMessages({
  library(tidyverse)
  library(lubridate)
  library(fs)
  library(rsample)
  library(yardstick)
  library(broom)
  library(ranger)
})

data_path <- fs::path("..", "data", "PackageData.csv")
outages_raw <- readr::read_csv(data_path, show_col_types = FALSE)
```

# Building modeling data for restoration time
```{r}
prepare_ert_data <- function(df) {
  df |>
  mutate(
    start_ts = ymd_hms(STARTDATE, tz = "UTC", quiet = TRUE),
    rest_ts  = ymd_hms(RESTDATE,  tz = "UTC", quiet = TRUE),
    duration_mins = as.numeric(difftime(rest_ts, start_ts, units = "mins")),
    outage_day  = as.Date(start_ts),
    start_hour  = hour(start_ts),
    weekday     = wday(start_ts, label = TRUE, week_start = 1),
    month       = month(start_ts, label = TRUE),
    is_momentary = MOMENTARYEVENTFLAG == 1) |>
  filter(
    !is.na(duration_mins),
    duration_mins >= 0) |>
  transmute(
    duration_mins,
    log_duration = log1p(duration_mins),
    TOTALCUSTAFFECTED = coalesce(TOTALCUSTAFFECTED, 0),
    is_momentary,
    DEVICETYPE  = factor(DEVICETYPE),
    XBORO       = factor(XBORO),
    TROUBLECODE = factor(TROUBLECODE),
    start_hour,
    weekday,
    month) |>
  drop_na()
  }

ert_df <- prepare_ert_data(outages_raw)

ert_df |> head()
summary(ert_df$duration_mins)
```

# Train/test split
```{r}
set.seed(42)

ert_split  <- initial_split(ert_df, prop = 0.8)
ert_train  <- training(ert_split)
ert_test   <- testing(ert_split)
```

# Baseline model: Linear reg
```{r}
fit_lm_ert <- function(train_df) {
  lm(log_duration ~ . - duration_mins, data = train_df)
}

lm_fit <- fit_lm_ert(ert_train)

summary(lm_fit)

predict_ert <- function(fit, new_data, response = c("log", "minutes")) {
  response <- match.arg(response)

  log_pred <- predict(fit, newdata = new_data)

  if (response == "log") {
    tibble(.pred_log = log_pred)
    } else {
      tibble(.pred = pmax(0, expm1(log_pred)))
    }
  }

lm_test_preds <- predict_ert(lm_fit, ert_test, response = "minutes") |>
  bind_cols(ert_test |> select(duration_mins))

lm_test_preds |> head()

ert_metrics <- function(truth, estimate, threshold = 30) {
  tibble(
    rmse  = rmse_vec(truth, estimate),
    mae   = mae_vec(truth, estimate),
    mape  = mape_vec(truth, estimate),
    pct_within_thr = mean(abs(estimate - truth) <= threshold))
  }

lm_perf <- ert_metrics(
  truth    = lm_test_preds$duration_mins,
  estimate = lm_test_preds$.pred,
  threshold = 30)

lm_perf
```

# Residual plot (LM)
```{r}
lm_test_preds |>
  mutate(
    resid = duration_mins - .pred) |>
  ggplot(aes(x = .pred, y = resid)) +
  geom_point(alpha = 0.3) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(
    title = "Residuals vs predicted restoration time (LM)",
    x = "Predicted duration (minutes)",
    y = "Residual (actual - predicted, minutes)") +
theme_minimal()
```

# RF
```{r}
fit_rf_ert <- function(train_df) {
  ranger(
  formula   = duration_mins ~ . - log_duration,
  data      = train_df,
  num.trees = 500,
  mtry      = floor(sqrt(ncol(train_df) - 2)),
  min.node.size = 10,
  importance = "impurity")
}

rf_fit <- fit_rf_ert(ert_train)
rf_fit

rf_test_preds <- predict(rf_fit, data = ert_test)$predictions |>
  as_tibble() |>
  rename(.pred = value) |>
  bind_cols(ert_test |> select(duration_mins))

rf_perf <- ert_metrics(
  truth    = rf_test_preds$duration_mins,
  estimate = rf_test_preds$.pred,
  threshold = 30
)

rf_perf
```

# Compare models
```{r}
bind_rows(
  lm   = lm_perf,
  rf   = rf_perf,
  .id = "model"
)
```

# Variable importance (RF)
```{r}
rf_vi <- enframe(rf_fit$variable.importance, 
                 name = "feature", 
                 value = "importance") |>
  arrange(desc(importance))

rf_vi |> head(10)

rf_vi |>
  slice_max(importance, n = 15) |>
  ggplot(aes(x = reorder(feature, importance), y = importance)) +
  geom_col() +
  coord_flip() +
  labs(
    title = "Random forest variable importance for restoration time",
    x = "Feature",
    y = "Importance") +
  theme_minimal()
```

